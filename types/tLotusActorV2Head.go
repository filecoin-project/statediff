package types

// Code generated by go-ipld-prime gengo.  DO NOT EDIT.

import (
	ipld "github.com/ipld/go-ipld-prime"
	"github.com/ipld/go-ipld-prime/node/mixins"
	"github.com/ipld/go-ipld-prime/schema"
)

type _LotusActorV2Head struct {
	tag uint
	x1 _MarketV2State
	x2 _MinerV2State
	x3 _PowerV2State
	x4 _RewardV2State
	x5 _AccountV0State
	x6 _CronV0State
	x7 _InitV0State
	x8 _MarketV0State
	x9 _MinerV0State
	x10 _MultisigV0State
	x11 _PaychV0State
	x12 _PowerV0State
	x13 _RewardV0State
	x14 _VerifregV0State
}
type LotusActorV2Head = *_LotusActorV2Head

type _LotusActorV2Head__iface interface {
	_LotusActorV2Head__member()
}
func (_MarketV2State) _LotusActorV2Head__member() {}
func (_MinerV2State) _LotusActorV2Head__member() {}
func (_PowerV2State) _LotusActorV2Head__member() {}
func (_RewardV2State) _LotusActorV2Head__member() {}
func (_AccountV0State) _LotusActorV2Head__member() {}
func (_CronV0State) _LotusActorV2Head__member() {}
func (_InitV0State) _LotusActorV2Head__member() {}
func (_MarketV0State) _LotusActorV2Head__member() {}
func (_MinerV0State) _LotusActorV2Head__member() {}
func (_MultisigV0State) _LotusActorV2Head__member() {}
func (_PaychV0State) _LotusActorV2Head__member() {}
func (_PowerV0State) _LotusActorV2Head__member() {}
func (_RewardV0State) _LotusActorV2Head__member() {}
func (_VerifregV0State) _LotusActorV2Head__member() {}
func (n _LotusActorV2Head) AsInterface() _LotusActorV2Head__iface {
	switch n.tag {
	case 1:
		return &n.x1
	case 2:
		return &n.x2
	case 3:
		return &n.x3
	case 4:
		return &n.x4
	case 5:
		return &n.x5
	case 6:
		return &n.x6
	case 7:
		return &n.x7
	case 8:
		return &n.x8
	case 9:
		return &n.x9
	case 10:
		return &n.x10
	case 11:
		return &n.x11
	case 12:
		return &n.x12
	case 13:
		return &n.x13
	case 14:
		return &n.x14
	default:
		panic("invalid union state; how did you create this object?")
	}
}
type _LotusActorV2Head__Maybe struct {
	m schema.Maybe
	v LotusActorV2Head
}
type MaybeLotusActorV2Head = *_LotusActorV2Head__Maybe

func (m MaybeLotusActorV2Head) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeLotusActorV2Head) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeLotusActorV2Head) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeLotusActorV2Head) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeLotusActorV2Head) Must() LotusActorV2Head {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
	memberName__LotusActorV2Head_MarketV2State = _String{"MarketV2State"}
	memberName__LotusActorV2Head_MinerV2State = _String{"MinerV2State"}
	memberName__LotusActorV2Head_PowerV2State = _String{"PowerV2State"}
	memberName__LotusActorV2Head_RewardV2State = _String{"RewardV2State"}
	memberName__LotusActorV2Head_AccountV0State = _String{"AccountV0State"}
	memberName__LotusActorV2Head_CronV0State = _String{"CronV0State"}
	memberName__LotusActorV2Head_InitV0State = _String{"InitV0State"}
	memberName__LotusActorV2Head_MarketV0State = _String{"MarketV0State"}
	memberName__LotusActorV2Head_MinerV0State = _String{"MinerV0State"}
	memberName__LotusActorV2Head_MultisigV0State = _String{"MultisigV0State"}
	memberName__LotusActorV2Head_PaychV0State = _String{"PaychV0State"}
	memberName__LotusActorV2Head_PowerV0State = _String{"PowerV0State"}
	memberName__LotusActorV2Head_RewardV0State = _String{"RewardV0State"}
	memberName__LotusActorV2Head_VerifregV0State = _String{"VerifregV0State"}
)
var _ ipld.Node = (LotusActorV2Head)(&_LotusActorV2Head{})
var _ schema.TypedNode = (LotusActorV2Head)(&_LotusActorV2Head{})
func (LotusActorV2Head) ReprKind() ipld.ReprKind {
	return ipld.ReprKind_Map
}
func (n LotusActorV2Head) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "MarketV2State":
		if n.tag != 1 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x1, nil
	case "MinerV2State":
		if n.tag != 2 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x2, nil
	case "PowerV2State":
		if n.tag != 3 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x3, nil
	case "RewardV2State":
		if n.tag != 4 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x4, nil
	case "AccountV0State":
		if n.tag != 5 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x5, nil
	case "CronV0State":
		if n.tag != 6 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x6, nil
	case "InitV0State":
		if n.tag != 7 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x7, nil
	case "MarketV0State":
		if n.tag != 8 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x8, nil
	case "MinerV0State":
		if n.tag != 9 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x9, nil
	case "MultisigV0State":
		if n.tag != 10 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x10, nil
	case "PaychV0State":
		if n.tag != 11 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x11, nil
	case "PowerV0State":
		if n.tag != 12 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x12, nil
	case "RewardV0State":
		if n.tag != 13 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x13, nil
	case "VerifregV0State":
		if n.tag != 14 {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return &n.x14, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n LotusActorV2Head) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (LotusActorV2Head) LookupByIndex(idx int) (ipld.Node, error) {
	return mixins.Map{"types.LotusActorV2Head"}.LookupByIndex(0)
}
func (n LotusActorV2Head) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n LotusActorV2Head) MapIterator() ipld.MapIterator {
	return &_LotusActorV2Head__MapItr{n, false}
}

type _LotusActorV2Head__MapItr struct {
	n LotusActorV2Head
	done bool
}

func (itr *_LotusActorV2Head__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.done {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.n.tag {
	case 1:
		k, v = &memberName__LotusActorV2Head_MarketV2State, &itr.n.x1
	case 2:
		k, v = &memberName__LotusActorV2Head_MinerV2State, &itr.n.x2
	case 3:
		k, v = &memberName__LotusActorV2Head_PowerV2State, &itr.n.x3
	case 4:
		k, v = &memberName__LotusActorV2Head_RewardV2State, &itr.n.x4
	case 5:
		k, v = &memberName__LotusActorV2Head_AccountV0State, &itr.n.x5
	case 6:
		k, v = &memberName__LotusActorV2Head_CronV0State, &itr.n.x6
	case 7:
		k, v = &memberName__LotusActorV2Head_InitV0State, &itr.n.x7
	case 8:
		k, v = &memberName__LotusActorV2Head_MarketV0State, &itr.n.x8
	case 9:
		k, v = &memberName__LotusActorV2Head_MinerV0State, &itr.n.x9
	case 10:
		k, v = &memberName__LotusActorV2Head_MultisigV0State, &itr.n.x10
	case 11:
		k, v = &memberName__LotusActorV2Head_PaychV0State, &itr.n.x11
	case 12:
		k, v = &memberName__LotusActorV2Head_PowerV0State, &itr.n.x12
	case 13:
		k, v = &memberName__LotusActorV2Head_RewardV0State, &itr.n.x13
	case 14:
		k, v = &memberName__LotusActorV2Head_VerifregV0State, &itr.n.x14
	default:
		panic("unreachable")
	}
	itr.done = true
	return
}
func (itr *_LotusActorV2Head__MapItr) Done() bool {
	return itr.done
}

func (LotusActorV2Head) ListIterator() ipld.ListIterator {
	return nil
}
func (LotusActorV2Head) Length() int {
	return 1
}
func (LotusActorV2Head) IsAbsent() bool {
	return false
}
func (LotusActorV2Head) IsNull() bool {
	return false
}
func (LotusActorV2Head) AsBool() (bool, error) {
	return mixins.Map{"types.LotusActorV2Head"}.AsBool()
}
func (LotusActorV2Head) AsInt() (int, error) {
	return mixins.Map{"types.LotusActorV2Head"}.AsInt()
}
func (LotusActorV2Head) AsFloat() (float64, error) {
	return mixins.Map{"types.LotusActorV2Head"}.AsFloat()
}
func (LotusActorV2Head) AsString() (string, error) {
	return mixins.Map{"types.LotusActorV2Head"}.AsString()
}
func (LotusActorV2Head) AsBytes() ([]byte, error) {
	return mixins.Map{"types.LotusActorV2Head"}.AsBytes()
}
func (LotusActorV2Head) AsLink() (ipld.Link, error) {
	return mixins.Map{"types.LotusActorV2Head"}.AsLink()
}
func (LotusActorV2Head) Prototype() ipld.NodePrototype {
	return _LotusActorV2Head__Prototype{}
}
type _LotusActorV2Head__Prototype struct{}

func (_LotusActorV2Head__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _LotusActorV2Head__Builder
	nb.Reset()
	return &nb
}
type _LotusActorV2Head__Builder struct {
	_LotusActorV2Head__Assembler
}
func (nb *_LotusActorV2Head__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_LotusActorV2Head__Builder) Reset() {
	var w _LotusActorV2Head
	var m schema.Maybe
	*nb = _LotusActorV2Head__Builder{_LotusActorV2Head__Assembler{w: &w, m: &m}}
}
type _LotusActorV2Head__Assembler struct {
	w *_LotusActorV2Head
	m *schema.Maybe
	state maState

	cm schema.Maybe
	ca1 _MarketV2State__Assembler
	
	ca2 _MinerV2State__Assembler
	
	ca3 _PowerV2State__Assembler
	
	ca4 _RewardV2State__Assembler
	
	ca5 _AccountV0State__Assembler
	
	ca6 _CronV0State__Assembler
	
	ca7 _InitV0State__Assembler
	
	ca8 _MarketV0State__Assembler
	
	ca9 _MinerV0State__Assembler
	
	ca10 _MultisigV0State__Assembler
	
	ca11 _PaychV0State__Assembler
	
	ca12 _PowerV0State__Assembler
	
	ca13 _RewardV0State__Assembler
	
	ca14 _VerifregV0State__Assembler
	ca uint
}
func (na *_LotusActorV2Head__Assembler) reset() {
	na.state = maState_initial
	switch na.ca {
	case 0:
		return
	case 1:
		na.ca1.reset()
	
	case 2:
		na.ca2.reset()
	
	case 3:
		na.ca3.reset()
	
	case 4:
		na.ca4.reset()
	
	case 5:
		na.ca5.reset()
	
	case 6:
		na.ca6.reset()
	
	case 7:
		na.ca7.reset()
	
	case 8:
		na.ca8.reset()
	
	case 9:
		na.ca9.reset()
	
	case 10:
		na.ca10.reset()
	
	case 11:
		na.ca11.reset()
	
	case 12:
		na.ca12.reset()
	
	case 13:
		na.ca13.reset()
	
	case 14:
		na.ca14.reset()
	default:
		panic("unreachable")
	}
	na.ca = 0
	na.cm = schema.Maybe_Absent
}
func (na *_LotusActorV2Head__Assembler) BeginMap(int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_LotusActorV2Head{}
	}
	return na, nil
}
func (_LotusActorV2Head__Assembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"types.LotusActorV2Head"}.BeginList(0)
}
func (na *_LotusActorV2Head__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"types.LotusActorV2Head"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_LotusActorV2Head__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"types.LotusActorV2Head"}.AssignBool(false)
}
func (_LotusActorV2Head__Assembler) AssignInt(int) error {
	return mixins.MapAssembler{"types.LotusActorV2Head"}.AssignInt(0)
}
func (_LotusActorV2Head__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"types.LotusActorV2Head"}.AssignFloat(0)
}
func (_LotusActorV2Head__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"types.LotusActorV2Head"}.AssignString("")
}
func (_LotusActorV2Head__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"types.LotusActorV2Head"}.AssignBytes(nil)
}
func (_LotusActorV2Head__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"types.LotusActorV2Head"}.AssignLink(nil)
}
func (na *_LotusActorV2Head__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_LotusActorV2Head); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.ReprKind() != ipld.ReprKind_Map {
		return ipld.ErrWrongKind{TypeName: "types.LotusActorV2Head", MethodName: "AssignNode", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: v.ReprKind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_LotusActorV2Head__Assembler) Prototype() ipld.NodePrototype {
	return _LotusActorV2Head__Prototype{}
}
func (ma *_LotusActorV2Head__Assembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:ma.state = maState_initial
		return true
	default:
		return false
	}
}
func (ma *_LotusActorV2Head__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly.
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	if ma.ca != 0 {
		return nil, schema.ErrNotUnionStructure{TypeName:"types.LotusActorV2Head", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "MarketV2State":
		ma.state = maState_midValue
		ma.ca = 1
		ma.w.tag = 1
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1, nil
	case "MinerV2State":
		ma.state = maState_midValue
		ma.ca = 2
		ma.w.tag = 2
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2, nil
	case "PowerV2State":
		ma.state = maState_midValue
		ma.ca = 3
		ma.w.tag = 3
		ma.ca3.w = &ma.w.x3
		ma.ca3.m = &ma.cm
		return &ma.ca3, nil
	case "RewardV2State":
		ma.state = maState_midValue
		ma.ca = 4
		ma.w.tag = 4
		ma.ca4.w = &ma.w.x4
		ma.ca4.m = &ma.cm
		return &ma.ca4, nil
	case "AccountV0State":
		ma.state = maState_midValue
		ma.ca = 5
		ma.w.tag = 5
		ma.ca5.w = &ma.w.x5
		ma.ca5.m = &ma.cm
		return &ma.ca5, nil
	case "CronV0State":
		ma.state = maState_midValue
		ma.ca = 6
		ma.w.tag = 6
		ma.ca6.w = &ma.w.x6
		ma.ca6.m = &ma.cm
		return &ma.ca6, nil
	case "InitV0State":
		ma.state = maState_midValue
		ma.ca = 7
		ma.w.tag = 7
		ma.ca7.w = &ma.w.x7
		ma.ca7.m = &ma.cm
		return &ma.ca7, nil
	case "MarketV0State":
		ma.state = maState_midValue
		ma.ca = 8
		ma.w.tag = 8
		ma.ca8.w = &ma.w.x8
		ma.ca8.m = &ma.cm
		return &ma.ca8, nil
	case "MinerV0State":
		ma.state = maState_midValue
		ma.ca = 9
		ma.w.tag = 9
		ma.ca9.w = &ma.w.x9
		ma.ca9.m = &ma.cm
		return &ma.ca9, nil
	case "MultisigV0State":
		ma.state = maState_midValue
		ma.ca = 10
		ma.w.tag = 10
		ma.ca10.w = &ma.w.x10
		ma.ca10.m = &ma.cm
		return &ma.ca10, nil
	case "PaychV0State":
		ma.state = maState_midValue
		ma.ca = 11
		ma.w.tag = 11
		ma.ca11.w = &ma.w.x11
		ma.ca11.m = &ma.cm
		return &ma.ca11, nil
	case "PowerV0State":
		ma.state = maState_midValue
		ma.ca = 12
		ma.w.tag = 12
		ma.ca12.w = &ma.w.x12
		ma.ca12.m = &ma.cm
		return &ma.ca12, nil
	case "RewardV0State":
		ma.state = maState_midValue
		ma.ca = 13
		ma.w.tag = 13
		ma.ca13.w = &ma.w.x13
		ma.ca13.m = &ma.cm
		return &ma.ca13, nil
	case "VerifregV0State":
		ma.state = maState_midValue
		ma.ca = 14
		ma.w.tag = 14
		ma.ca14.w = &ma.w.x14
		ma.ca14.m = &ma.cm
		return &ma.ca14, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"types.LotusActorV2Head", Key:&_String{k}}
	}
}
func (ma *_LotusActorV2Head__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly... or rather, the keyassembler will be.
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_LotusActorV2Head__KeyAssembler)(ma)
}
func (ma *_LotusActorV2Head__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.ca {
	case 0:
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1
	case 1:
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2
	case 2:
		ma.ca3.w = &ma.w.x3
		ma.ca3.m = &ma.cm
		return &ma.ca3
	case 3:
		ma.ca4.w = &ma.w.x4
		ma.ca4.m = &ma.cm
		return &ma.ca4
	case 4:
		ma.ca5.w = &ma.w.x5
		ma.ca5.m = &ma.cm
		return &ma.ca5
	case 5:
		ma.ca6.w = &ma.w.x6
		ma.ca6.m = &ma.cm
		return &ma.ca6
	case 6:
		ma.ca7.w = &ma.w.x7
		ma.ca7.m = &ma.cm
		return &ma.ca7
	case 7:
		ma.ca8.w = &ma.w.x8
		ma.ca8.m = &ma.cm
		return &ma.ca8
	case 8:
		ma.ca9.w = &ma.w.x9
		ma.ca9.m = &ma.cm
		return &ma.ca9
	case 9:
		ma.ca10.w = &ma.w.x10
		ma.ca10.m = &ma.cm
		return &ma.ca10
	case 10:
		ma.ca11.w = &ma.w.x11
		ma.ca11.m = &ma.cm
		return &ma.ca11
	case 11:
		ma.ca12.w = &ma.w.x12
		ma.ca12.m = &ma.cm
		return &ma.ca12
	case 12:
		ma.ca13.w = &ma.w.x13
		ma.ca13.m = &ma.cm
		return &ma.ca13
	case 13:
		ma.ca14.w = &ma.w.x14
		ma.ca14.m = &ma.cm
		return &ma.ca14
	default:
		panic("unreachable")
	}
}
func (ma *_LotusActorV2Head__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.ca == 0 {
		return schema.ErrNotUnionStructure{TypeName:"types.LotusActorV2Head", Detail: "a union must have exactly one entry (not none)!"}
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_LotusActorV2Head__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_LotusActorV2Head__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	switch k {
	case "MarketV2State":
		return _MarketV2State__Prototype{}
	case "MinerV2State":
		return _MinerV2State__Prototype{}
	case "PowerV2State":
		return _PowerV2State__Prototype{}
	case "RewardV2State":
		return _RewardV2State__Prototype{}
	case "AccountV0State":
		return _AccountV0State__Prototype{}
	case "CronV0State":
		return _CronV0State__Prototype{}
	case "InitV0State":
		return _InitV0State__Prototype{}
	case "MarketV0State":
		return _MarketV0State__Prototype{}
	case "MinerV0State":
		return _MinerV0State__Prototype{}
	case "MultisigV0State":
		return _MultisigV0State__Prototype{}
	case "PaychV0State":
		return _PaychV0State__Prototype{}
	case "PowerV0State":
		return _PowerV0State__Prototype{}
	case "RewardV0State":
		return _RewardV0State__Prototype{}
	case "VerifregV0State":
		return _VerifregV0State__Prototype{}
	default:
		return nil
	}
}
type _LotusActorV2Head__KeyAssembler _LotusActorV2Head__Assembler
func (_LotusActorV2Head__KeyAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"types.LotusActorV2Head.KeyAssembler"}.BeginMap(0)
}
func (_LotusActorV2Head__KeyAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"types.LotusActorV2Head.KeyAssembler"}.BeginList(0)
}
func (na *_LotusActorV2Head__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"types.LotusActorV2Head.KeyAssembler"}.AssignNull()
}
func (_LotusActorV2Head__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"types.LotusActorV2Head.KeyAssembler"}.AssignBool(false)
}
func (_LotusActorV2Head__KeyAssembler) AssignInt(int) error {
	return mixins.StringAssembler{"types.LotusActorV2Head.KeyAssembler"}.AssignInt(0)
}
func (_LotusActorV2Head__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"types.LotusActorV2Head.KeyAssembler"}.AssignFloat(0)
}
func (ka *_LotusActorV2Head__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	if ka.ca != 0 {
		return schema.ErrNotUnionStructure{TypeName:"types.LotusActorV2Head", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "MarketV2State":
		ka.ca = 1
		ka.w.tag = 1
		ka.state = maState_expectValue
		return nil
	case "MinerV2State":
		ka.ca = 2
		ka.w.tag = 2
		ka.state = maState_expectValue
		return nil
	case "PowerV2State":
		ka.ca = 3
		ka.w.tag = 3
		ka.state = maState_expectValue
		return nil
	case "RewardV2State":
		ka.ca = 4
		ka.w.tag = 4
		ka.state = maState_expectValue
		return nil
	case "AccountV0State":
		ka.ca = 5
		ka.w.tag = 5
		ka.state = maState_expectValue
		return nil
	case "CronV0State":
		ka.ca = 6
		ka.w.tag = 6
		ka.state = maState_expectValue
		return nil
	case "InitV0State":
		ka.ca = 7
		ka.w.tag = 7
		ka.state = maState_expectValue
		return nil
	case "MarketV0State":
		ka.ca = 8
		ka.w.tag = 8
		ka.state = maState_expectValue
		return nil
	case "MinerV0State":
		ka.ca = 9
		ka.w.tag = 9
		ka.state = maState_expectValue
		return nil
	case "MultisigV0State":
		ka.ca = 10
		ka.w.tag = 10
		ka.state = maState_expectValue
		return nil
	case "PaychV0State":
		ka.ca = 11
		ka.w.tag = 11
		ka.state = maState_expectValue
		return nil
	case "PowerV0State":
		ka.ca = 12
		ka.w.tag = 12
		ka.state = maState_expectValue
		return nil
	case "RewardV0State":
		ka.ca = 13
		ka.w.tag = 13
		ka.state = maState_expectValue
		return nil
	case "VerifregV0State":
		ka.ca = 14
		ka.w.tag = 14
		ka.state = maState_expectValue
		return nil
	default:
		return ipld.ErrInvalidKey{TypeName:"types.LotusActorV2Head", Key:&_String{k}} // TODO: error quality: ErrInvalidUnionDiscriminant ?
	}
	return nil
}
func (_LotusActorV2Head__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"types.LotusActorV2Head.KeyAssembler"}.AssignBytes(nil)
}
func (_LotusActorV2Head__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"types.LotusActorV2Head.KeyAssembler"}.AssignLink(nil)
}
func (ka *_LotusActorV2Head__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_LotusActorV2Head__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (LotusActorV2Head) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n LotusActorV2Head) Representation() ipld.Node {
	return (*_LotusActorV2Head__Repr)(n)
}
type _LotusActorV2Head__Repr _LotusActorV2Head
var _ ipld.Node = &_LotusActorV2Head__Repr{}
func (n *_LotusActorV2Head__Repr) ReprKind() ipld.ReprKind {
	switch n.tag {
	case 1:
		return ipld.ReprKind_List
	case 2:
		return ipld.ReprKind_List
	case 3:
		return ipld.ReprKind_List
	case 4:
		return ipld.ReprKind_List
	case 5:
		return ipld.ReprKind_List
	case 6:
		return ipld.ReprKind_List
	case 7:
		return ipld.ReprKind_List
	case 8:
		return ipld.ReprKind_List
	case 9:
		return ipld.ReprKind_List
	case 10:
		return ipld.ReprKind_List
	case 11:
		return ipld.ReprKind_List
	case 12:
		return ipld.ReprKind_List
	case 13:
		return ipld.ReprKind_List
	case 14:
		return ipld.ReprKind_List
	default:
		panic("unreachable")
	}
}
func (n *_LotusActorV2Head__Repr) LookupByString(key string) (ipld.Node, error) {
		return nil, ipld.ErrWrongKind{TypeName: "types.LotusActorV2Head.Repr", MethodName: "LookupByString", AppropriateKind: ipld.ReprKindSet_JustMap, ActualKind: n.ReprKind()}
}
func (n *_LotusActorV2Head__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
		return nil, ipld.ErrWrongKind{TypeName: "types.LotusActorV2Head.Repr", MethodName: "LookupByNode", AppropriateKind: ipld.ReprKindSet_Recursive, ActualKind: n.ReprKind()}
}
func (n *_LotusActorV2Head__Repr) LookupByIndex(idx int) (ipld.Node, error) {
		return nil, ipld.ErrWrongKind{TypeName: "types.LotusActorV2Head.Repr", MethodName: "LookupByIndex", AppropriateKind: ipld.ReprKindSet_JustList, ActualKind: n.ReprKind()}
}
func (n *_LotusActorV2Head__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
		return nil, ipld.ErrWrongKind{TypeName: "types.LotusActorV2Head.Repr", MethodName: "LookupBySegment", AppropriateKind: ipld.ReprKindSet_Recursive, ActualKind: n.ReprKind()}
}
func (n *_LotusActorV2Head__Repr) MapIterator() ipld.MapIterator {
		return nil
}
func (n *_LotusActorV2Head__Repr) ListIterator() ipld.ListIterator {
		return nil
}
func (n *_LotusActorV2Head__Repr) Length() int {
		return -1
}
func (n *_LotusActorV2Head__Repr) IsAbsent() bool {
	return false
}
func (n *_LotusActorV2Head__Repr) IsNull() bool {
	return false
}
func (n *_LotusActorV2Head__Repr) AsBool() (bool, error) {
		return false, ipld.ErrWrongKind{TypeName: "types.LotusActorV2Head.Repr", MethodName: "AsBool", AppropriateKind: ipld.ReprKindSet_JustBool, ActualKind: n.ReprKind()}
}
func (n *_LotusActorV2Head__Repr) AsInt() (int, error) {
		return 0, ipld.ErrWrongKind{TypeName: "types.LotusActorV2Head.Repr", MethodName: "AsInt", AppropriateKind: ipld.ReprKindSet_JustInt, ActualKind: n.ReprKind()}
}
func (n *_LotusActorV2Head__Repr) AsFloat() (float64, error) {
		return 0, ipld.ErrWrongKind{TypeName: "types.LotusActorV2Head.Repr", MethodName: "AsFloat", AppropriateKind: ipld.ReprKindSet_JustFloat, ActualKind: n.ReprKind()}
}
func (n *_LotusActorV2Head__Repr) AsString() (string, error) {
		return "", ipld.ErrWrongKind{TypeName: "types.LotusActorV2Head.Repr", MethodName: "AsString", AppropriateKind: ipld.ReprKindSet_JustString, ActualKind: n.ReprKind()}
}
func (n *_LotusActorV2Head__Repr) AsBytes() ([]byte, error) {
		return nil, ipld.ErrWrongKind{TypeName: "types.LotusActorV2Head.Repr", MethodName: "AsBytes", AppropriateKind: ipld.ReprKindSet_JustBytes, ActualKind: n.ReprKind()}
}
func (n *_LotusActorV2Head__Repr) AsLink() (ipld.Link, error) {
		return nil, ipld.ErrWrongKind{TypeName: "types.LotusActorV2Head.Repr", MethodName: "AsLink", AppropriateKind: ipld.ReprKindSet_JustLink, ActualKind: n.ReprKind()}
}
func (_LotusActorV2Head__Repr) Prototype() ipld.NodePrototype {
	return _LotusActorV2Head__ReprPrototype{}
}
type _LotusActorV2Head__ReprPrototype struct{}

func (_LotusActorV2Head__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _LotusActorV2Head__ReprBuilder
	nb.Reset()
	return &nb
}
type _LotusActorV2Head__ReprBuilder struct {
	_LotusActorV2Head__ReprAssembler
}
func (nb *_LotusActorV2Head__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_LotusActorV2Head__ReprBuilder) Reset() {
	var w _LotusActorV2Head
	var m schema.Maybe
	*nb = _LotusActorV2Head__ReprBuilder{_LotusActorV2Head__ReprAssembler{w: &w, m: &m}}
}
type _LotusActorV2Head__ReprAssembler struct {
	w *_LotusActorV2Head
	m *schema.Maybe
	ca1 _MarketV2State__ReprAssembler
	ca2 _MinerV2State__ReprAssembler
	ca3 _PowerV2State__ReprAssembler
	ca4 _RewardV2State__ReprAssembler
	ca5 _AccountV0State__ReprAssembler
	ca6 _CronV0State__ReprAssembler
	ca7 _InitV0State__ReprAssembler
	ca8 _MarketV0State__ReprAssembler
	ca9 _MinerV0State__ReprAssembler
	ca10 _MultisigV0State__ReprAssembler
	ca11 _PaychV0State__ReprAssembler
	ca12 _PowerV0State__ReprAssembler
	ca13 _RewardV0State__ReprAssembler
	ca14 _VerifregV0State__ReprAssembler
	ca uint
}
func (na *_LotusActorV2Head__ReprAssembler) reset() {
	switch na.ca {
	case 0:
		return
	case 1:
		na.ca1.reset()
	case 2:
		na.ca2.reset()
	case 3:
		na.ca3.reset()
	case 4:
		na.ca4.reset()
	case 5:
		na.ca5.reset()
	case 6:
		na.ca6.reset()
	case 7:
		na.ca7.reset()
	case 8:
		na.ca8.reset()
	case 9:
		na.ca9.reset()
	case 10:
		na.ca10.reset()
	case 11:
		na.ca11.reset()
	case 12:
		na.ca12.reset()
	case 13:
		na.ca13.reset()
	case 14:
		na.ca14.reset()
	default:
		panic("unreachable")
	}
	na.ca = 0
}
func (na *_LotusActorV2Head__ReprAssembler) BeginMap(sizeHint int) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign into assembler that's already working on a larger structure!")
	}
	return nil, schema.ErrNotUnionStructure{TypeName: "types.LotusActorV2Head.Repr", Detail: "BeginMap called but is not valid for any of the kinds that are valid members of this union"}
}
func (na *_LotusActorV2Head__ReprAssembler) BeginList(sizeHint int) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign into assembler that's already working on a larger structure!")
	}
	if na.w == nil {
		na.w = &_LotusActorV2Head{}
	}
	na.ca = 1
	na.w.tag = 1
	na.ca1.w = &na.w.x1
	na.ca1.m = na.m
	return na.ca1.BeginList(sizeHint)
	if na.w == nil {
		na.w = &_LotusActorV2Head{}
	}
	na.ca = 2
	na.w.tag = 2
	na.ca2.w = &na.w.x2
	na.ca2.m = na.m
	return na.ca2.BeginList(sizeHint)
	if na.w == nil {
		na.w = &_LotusActorV2Head{}
	}
	na.ca = 3
	na.w.tag = 3
	na.ca3.w = &na.w.x3
	na.ca3.m = na.m
	return na.ca3.BeginList(sizeHint)
	if na.w == nil {
		na.w = &_LotusActorV2Head{}
	}
	na.ca = 4
	na.w.tag = 4
	na.ca4.w = &na.w.x4
	na.ca4.m = na.m
	return na.ca4.BeginList(sizeHint)
	if na.w == nil {
		na.w = &_LotusActorV2Head{}
	}
	na.ca = 5
	na.w.tag = 5
	na.ca5.w = &na.w.x5
	na.ca5.m = na.m
	return na.ca5.BeginList(sizeHint)
	if na.w == nil {
		na.w = &_LotusActorV2Head{}
	}
	na.ca = 6
	na.w.tag = 6
	na.ca6.w = &na.w.x6
	na.ca6.m = na.m
	return na.ca6.BeginList(sizeHint)
	if na.w == nil {
		na.w = &_LotusActorV2Head{}
	}
	na.ca = 7
	na.w.tag = 7
	na.ca7.w = &na.w.x7
	na.ca7.m = na.m
	return na.ca7.BeginList(sizeHint)
	if na.w == nil {
		na.w = &_LotusActorV2Head{}
	}
	na.ca = 8
	na.w.tag = 8
	na.ca8.w = &na.w.x8
	na.ca8.m = na.m
	return na.ca8.BeginList(sizeHint)
	if na.w == nil {
		na.w = &_LotusActorV2Head{}
	}
	na.ca = 9
	na.w.tag = 9
	na.ca9.w = &na.w.x9
	na.ca9.m = na.m
	return na.ca9.BeginList(sizeHint)
	if na.w == nil {
		na.w = &_LotusActorV2Head{}
	}
	na.ca = 10
	na.w.tag = 10
	na.ca10.w = &na.w.x10
	na.ca10.m = na.m
	return na.ca10.BeginList(sizeHint)
	if na.w == nil {
		na.w = &_LotusActorV2Head{}
	}
	na.ca = 11
	na.w.tag = 11
	na.ca11.w = &na.w.x11
	na.ca11.m = na.m
	return na.ca11.BeginList(sizeHint)
	if na.w == nil {
		na.w = &_LotusActorV2Head{}
	}
	na.ca = 12
	na.w.tag = 12
	na.ca12.w = &na.w.x12
	na.ca12.m = na.m
	return na.ca12.BeginList(sizeHint)
	if na.w == nil {
		na.w = &_LotusActorV2Head{}
	}
	na.ca = 13
	na.w.tag = 13
	na.ca13.w = &na.w.x13
	na.ca13.m = na.m
	return na.ca13.BeginList(sizeHint)
	if na.w == nil {
		na.w = &_LotusActorV2Head{}
	}
	na.ca = 14
	na.w.tag = 14
	na.ca14.w = &na.w.x14
	na.ca14.m = na.m
	return na.ca14.BeginList(sizeHint)
	return nil, schema.ErrNotUnionStructure{TypeName: "types.LotusActorV2Head.Repr", Detail: "BeginList called but is not valid for any of the kinds that are valid members of this union"}
}
func (na *_LotusActorV2Head__ReprAssembler) AssignNull() error  {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign into assembler that's already working on a larger structure!")
	}
	return  schema.ErrNotUnionStructure{TypeName: "types.LotusActorV2Head.Repr", Detail: "AssignNull called but is not valid for any of the kinds that are valid members of this union"}
}
func (na *_LotusActorV2Head__ReprAssembler) AssignBool(v bool) error  {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign into assembler that's already working on a larger structure!")
	}
	return  schema.ErrNotUnionStructure{TypeName: "types.LotusActorV2Head.Repr", Detail: "AssignBool called but is not valid for any of the kinds that are valid members of this union"}
}
func (na *_LotusActorV2Head__ReprAssembler) AssignInt(v int) error  {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign into assembler that's already working on a larger structure!")
	}
	return  schema.ErrNotUnionStructure{TypeName: "types.LotusActorV2Head.Repr", Detail: "AssignInt called but is not valid for any of the kinds that are valid members of this union"}
}
func (na *_LotusActorV2Head__ReprAssembler) AssignFloat(v float64) error  {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign into assembler that's already working on a larger structure!")
	}
	return  schema.ErrNotUnionStructure{TypeName: "types.LotusActorV2Head.Repr", Detail: "AssignFloat called but is not valid for any of the kinds that are valid members of this union"}
}
func (na *_LotusActorV2Head__ReprAssembler) AssignString(v string) error  {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign into assembler that's already working on a larger structure!")
	}
	return  schema.ErrNotUnionStructure{TypeName: "types.LotusActorV2Head.Repr", Detail: "AssignString called but is not valid for any of the kinds that are valid members of this union"}
}
func (na *_LotusActorV2Head__ReprAssembler) AssignBytes(v []byte) error  {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign into assembler that's already working on a larger structure!")
	}
	return  schema.ErrNotUnionStructure{TypeName: "types.LotusActorV2Head.Repr", Detail: "AssignBytes called but is not valid for any of the kinds that are valid members of this union"}
}
func (na *_LotusActorV2Head__ReprAssembler) AssignLink(v ipld.Link) error  {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign into assembler that's already working on a larger structure!")
	}
	return  schema.ErrNotUnionStructure{TypeName: "types.LotusActorV2Head.Repr", Detail: "AssignLink called but is not valid for any of the kinds that are valid members of this union"}
}
func (na *_LotusActorV2Head__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_LotusActorV2Head); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	switch v.ReprKind() {
	case ipld.ReprKind_Bool:
		v2, _ := v.AsBool()
		return na.AssignBool(v2)
	case ipld.ReprKind_Int:
		v2, _ := v.AsInt()
		return na.AssignInt(v2)
	case ipld.ReprKind_Float:
		v2, _ := v.AsFloat()
		return na.AssignFloat(v2)
	case ipld.ReprKind_String:
		v2, _ := v.AsString()
		return na.AssignString(v2)
	case ipld.ReprKind_Bytes:
		v2, _ := v.AsBytes()
		return na.AssignBytes(v2)
	case ipld.ReprKind_Map:
		na, err := na.BeginMap(v.Length())
		if err != nil {
			return err
		}
		itr := v.MapIterator()
		for !itr.Done() {
			k, v, err := itr.Next()
			if err != nil {
				return err
			}
			if err := na.AssembleKey().AssignNode(k); err != nil {
				return err
			}
			if err := na.AssembleValue().AssignNode(v); err != nil {
				return err
			}
		}
		return na.Finish()
	case ipld.ReprKind_List:
		na, err := na.BeginList(v.Length())
		if err != nil {
			return err
		}
		itr := v.ListIterator()
		for !itr.Done() {
			_, v, err := itr.Next()
			if err != nil {
				return err
			}
			if err := na.AssembleValue().AssignNode(v); err != nil {
				return err
			}
		}
		return na.Finish()
	case ipld.ReprKind_Link:
		v2, _ := v.AsLink()
		return na.AssignLink(v2)
	default:
		panic("unreachable")
	}
}
func (na *_LotusActorV2Head__ReprAssembler) Prototype() ipld.NodePrototype {
	return _LotusActorV2Head__ReprPrototype{}
}
